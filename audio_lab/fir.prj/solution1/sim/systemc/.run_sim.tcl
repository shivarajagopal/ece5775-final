# ==============================================================
# File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
# Version: 2014.2
# Copyright (C) 2014 Xilinx Inc. All rights reserved.
# 
# ==============================================================

set ::env(LD_LIBRARY_PATH) /opt/xilinx/Vivado_HLS/2014.2/lnx64/tools/fpo_v7_0:$::env(LD_LIBRARY_PATH)
set ::env(LD_LIBRARY_PATH) /opt/xilinx/Vivado_HLS/2014.2/lnx64/tools/opencv:$::env(LD_LIBRARY_PATH)
set ::env(LD_LIBRARY_PATH) /opt/xilinx/Vivado_HLS/2014.2/lnx64/tools/fft_v9_0:$::env(LD_LIBRARY_PATH)
set ::env(LD_LIBRARY_PATH) /opt/xilinx/Vivado_HLS/2014.2/lnx64/tools/fir_v7_0:$::env(LD_LIBRARY_PATH)
source check_sim.tcl
proc cpvcdfromsctortl {} {
    #copy *.vcd from sc to verilog/vhdl dir
    if {$::AESL_AUTOSIM::gTraceLevel == "all"} {
        set filefnd [catch { set vcdFiles [glob *.vcd] } err]
        if {!$filefnd} {
            if { ${::AESL_AUTOSIM::gLang} == "vlog" } {
                foreach vcdf $vcdFiles {
                    if { [file exist $vcdf] } {
                        safe_copy $vcdf [file join ../verilog $vcdf] 1
                    }
                }
            } elseif { ${::AESL_AUTOSIM::gLang} == "vhdl" } {
                foreach vcdf $vcdFiles {
                    if {[file exist $vcdf]} {
                        safe_copy $vcdf [file join ../vhdl $vcdf] 1
                    }
                }
            }
        }
    }
}

proc run_exec { fileExe } {
   if {![file exists $fileExe]} {
        set err_code 314
        dump_message $err_code $fileExe
        return -code error -errorcode 10
    }
    set ret [catch {eval exec "./$fileExe | tee tmp.log" >&@ stdout} err]
    cpfilecontent tmp.log ../../.temp11.log
    set errfile "err.log"
    if {$errfile != ""} {
            if {[file exists $errfile] &&  \
                [file size $errfile] != 0} {
                set fl [open $errfile r]
                while {[gets $fl line] >= 0} {
                    if {[string first "AESL_mErrNo = " $line] == 0} {
                        set mismatch_num [string range $line [string length "AESL_mErrNo = "] end]
                        if {$mismatch_num != 0} {
                            set info_code 301
                            dump_message $info_code ${mismatch_num}
                            break
                        }
                    }
                }
            }
    }
    if {$ret || $err != ""} {
        set err_code 357
        if {$fileExe == "cosim.pc.exe"} {
            set err_code 361
        }
        if { [lindex $::errorCode 0] eq "CHILDSTATUS"} {
            set status [lindex $::errorCode 2]
            if {$status != ""} {
                dump_message $err_code $status
            } else {
                set err_code [expr $err_code + 1]
                dump_message $err_code
            }
        } else {
             set err_code [expr $err_code + 1]
             dump_message $err_code
        }
        return -code error -errorcode $err
    }
    if {[file exists tmp.log]} {
        set cmdret [catch {eval exec "grep \"Error:\" tmp.log"} err]
        file delete tmp.log
        if {$cmdret == 0} {
             set err_code 304
             dump_message $err_code
            return -code error -errorcode $err
        }
    }
    return 1
}

proc run_sc { {FileExe "cosim.sc.exe"} } {
    set errfile "err.log"
    if {$errfile != "" && [file exist $errfile]}  {
        file delete -force  $errfile
    }
    set ret [catch {run_exec $FileExe} results]
    if {$ret } {
        cpvcdfromsctortl
        return -code error -errorcode $::errorCode
    }
    if {$errfile != ""} {
        if {[file exist $errfile] &&  \
            [file size $errfile] != 0} {
            cpvcdfromsctortl
            return -code error -errorcode 3
        }
    }
    return 1
}

proc sim { } {

    ###set default values
    set gTvIn ""
    set gTvOut ""
    set gTb ""
    set gHdlTvIn ""
    set gHdlTvOut ""
    set gAutowrap 1

    #check if autosim correctly exit
    set simStatusTcl .sim.status.tcl
    if { ![file exist $simStatusTcl]} {
        set err_code 305
        dump_message $err_code
        return -code error -errorcode 4
    }

    #get parameters from autosim generated tcl script
    source $simStatusTcl
    
    set sim_st(wrapc_needed)    ${sim_status(wrapc_needed)}
    set sim_st(bc_needed)       ${sim_status(bc_needed)}
    set sim_st(sc_needed)       ${sim_status(sc_needed)}
    set sim_st(pc_needed)       ${sim_status(pc_needed)}
    set sim_st(vhdl_needed)     ${sim_status(vhdl_needed)}
    set sim_st(vlog_needed)     ${sim_status(vlog_needed)}
    set sim_st(bc_tb_needed)    ${sim_status(bc_tb_needed)}
    set sim_st(cas_needed)      ${sim_status(cas_needed)}
    set dirAutoSimRoot          ${sim_DirAutoSimRoot}
    set dirAutoSimTv            ${sim_DirAutoSimTv}
    set dirAutoSimBc            ${sim_DirAutoSimBc}
    set dirAutoSimSc            ${sim_DirAutoSimSc}
    set dirAutoSimPostCheck     ${sim_DirAutoSimPostCheck}
    set dirAutoSimCasSc         ${sim_DirAutoSimCasSc}
    set dirAutoSimVhdl          ${sim_DirAutoSimVhdl}
    set dirAutoSimVlog          ${sim_DirAutoSimVlog}
    set dirAutoSimVlogGate      ${sim_DirAutoSimVlogGate}
    set dirAutoSimWrapc         ${sim_DirAutoSimWrapc}
    set gWorkingDir             [file normalize ${sim_WorkingDir}]
    set constFileTvIn           ${sim_ConstFileTvIn}
    set constFileTvOut          ${sim_ConstFileTvOut}
    set constFileHdlTvIn        ${sim_ConstFileHdlTvIn}
    set constFileHdlTvOut       ${sim_ConstFileHdlTvOut}
    set gGateLevelSim           ${sim_GateLevelSim}
    set gAutowrap               ${sim_GAutowrap}
    set gTool                   ${sim_GTool}
    set gTvIn                   [file normalize ${sim_GTvIn}]
    set gTvOut                  [file normalize ${sim_GTvOut}]
    set gHdlTvIn                [file normalize ${sim_GHdlTvIn}]
    set gHdlTvOut               [file normalize ${sim_GHdlTvOut}]

        cd ${gWorkingDir}
        cd ${dirAutoSimTv}/cdatafile
        set ret [check_tvin_file]
        if {$ret == 1} {
            set error_code 344
            dump_message $error_code
            return -code error -errorcode $::errorCode
        }
 
#======================sc section======================
        set info_code 11 
        dump_message $info_code "SystemC" 
        cd ${gWorkingDir}
        cd ${dirAutoSimSc}
        if {[catch {eval run_sc} err00]} {
            return -code error -errorcode $::errorCode
        }
        set my_retHdlTvInFiles {}
        set my_retHdlTvOutFiles {}
        if {[file isfile $constFileHdlTvIn]} {
            set my_retHdlTvInFiles [file normalize $constFileHdlTvIn]
        }
        if {[file isfile $constFileHdlTvOut]} {
            set my_retHdlTvOutFiles [file normalize $constFileHdlTvOut]
        }
        set ret [catch {eval exec "du -sh"} disk_space]
        cd ${gWorkingDir}
        set gHdlTvIn {}
        set gHdlTvOut {}
        foreach {fl} $my_retHdlTvInFiles {
            if {[file isfile $fl]} {
                set file [file normalize $fl]
                set filename [file tail $file]
                set dstfile [file join $dirAutoSimTv $filename]
                safe_move $file $dstfile 1
                lappend gHdlTvIn [file normalize $dstfile]
            }
        }
        foreach {fl} $my_retHdlTvOutFiles {
            if {[file isfile $fl]} {
                set file [file normalize $fl]
                set filename [file tail $file]
                set dstfile [file join $dirAutoSimTv $filename]
                safe_move $file $dstfile 1
                lappend gHdlTvOut [file normalize $dstfile]
            }
        }
#======================sc section end===================

        cd ${gWorkingDir}
        cd ${dirAutoSimTv}/rtldatafile
        set ret [check_tvout_file]
        if {$ret == 1} {
            set error_code 344
            dump_message $error_code
            return -code error -errorcode $::errorCode
        }
        set ret [catch {eval exec "date +%s"} start_time]
        set info_code 316
        dump_message $info_code
        cd ${gWorkingDir}
        cd ${dirAutoSimPostCheck}
        if {[catch {eval run_sc "cosim.pc.exe"} err00]} {
            return -code error -errorcode $::errorCode
        }

 
    return 1
}

proc sim_wrap { } {
    set ret [catch {eval sim} err01]

    if {$ret} {
        return -code error -errorcode $::errorCode
    } else {
        return 0
    }
}

sim_wrap
